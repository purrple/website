---
title: Unicode, utf-8, strings and emojis
author: Romain Fran√ßois
date: '2017-08-03'
slug: unicode-utf-8-strings-and-emojis
categories: []
tags:
  - unicode
  - utf8
  - strings
  - emojis
  - utf8splain
  - uni
  - package
  - R
banner: "img/banners/utf8splain.png"
---



<p>I‚Äôve been somewhat obsessing about emojis lately, it all started when I wanted to check which emojis were used <a href="http://romain.rbind.io/blog/2017/07/11/emojis-at-user2017/">on twitter</a> during useR this year.</p>
{{< tweet 883199852347367424 >}}
<p>But this post is not really about emojis, because my <a href="https://github.com/ThinkRstat/emojitsu">emojitsu</a> package is not ready yet, but here‚Äôs a preview anyway.</p>
{{< tweet 892375718247706626 >}}
<p>So I‚Äôll blog specifically about emojis later, but this has led me to digress down the üêá hole, because emojis are made of unicode runes typically encoded into utf-8 strings. Most of the concepts in that last sentence were quite mysterious to me not so long ago, and I believe we should collectively know more about unicode and utf-8. I learned some of the basics from the <a href="https://blog.golang.org/strings">Strings, bytes, runes and characters in Go</a> post in the go blog, and <a href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/">The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)</a>.</p>
<p>Typically when I want to understand something, I make an R package, I guess I really want to understand this, as I am making not 1, not 2 but 3 packages (if I count <code>emojitsu</code>).</p>
<ul>
<li><code>uni</code> : contains a tibble of unicode runes</li>
<li><code>utf8splain</code> : to get to the 0 and 1 of utf-8 string encoding</li>
<li><code>emojitsu</code> : grammar of emoji, or at least programmatic manipulation of them.</li>
</ul>
<p>The world has changed now, and strings can no longer be considered as mere sequences of single characters (bytes). The <code>uni::code</code> tibble contains the 82719 unicode runes (aka code points). btw, the generation of the <code>uni::code</code> tibble contains some interesting tidyverse gymnatics, perhaps I‚Äôll write another post about that, but let‚Äôs not digress more yet.</p>
<pre class="r"><code>uni::code</code></pre>
<pre><code>## # A tibble: 82,719 x 7
##       id   rune                                              description
##    &lt;int&gt;  &lt;chr&gt;                                                    &lt;chr&gt;
##  1     0 U+0000                                               Null : NUL
##  2     1 U+0001                                   Start of Heading : SOH
##  3     2 U+0002                                      Start of Text : STX
##  4     3 U+0003                                        End of Text : ETX
##  5     4 U+0004                                End of Transmission : EOT
##  6     5 U+0005                                            Enquiry : ENQ
##  7     6 U+0006                                        Acknowledge : ASK
##  8     7 U+0007                                               Bell : BEL
##  9     8 U+0008                                           Backspace : BS
## 10     9 U+0009  Horizontal Tabulation : ht : character tabulation : TAB
## # ... with 82,709 more rows, and 4 more variables: block &lt;chr&gt;,
## #   countries &lt;chr&gt;, languages &lt;chr&gt;, type &lt;chr&gt;</code></pre>
<p>So as of now, unicode has 82719 runes, that‚Äôs way more than the 256 that can fit into a single byte (8 bits), however we still want to be able to process text from back in the days when strings were in fact arrays of single bytes.</p>
<p>Unicode is just a giant map of characters, that covers all languages, emojis and other things I don‚Äôt know about, currently ranging between U+0000 and U+E01EF.</p>
<pre class="r"><code>uni::code %&gt;%
  slice( c(1, n()) )</code></pre>
<pre><code>## # A tibble: 2 x 7
##       id    rune             description                          block
##    &lt;int&gt;   &lt;chr&gt;                   &lt;chr&gt;                          &lt;chr&gt;
## 1      0  U+0000              Null : NUL              control-character
## 2 917999 U+E01EF  VARIATION SELECTOR-256 variation-selectors-supplement
## # ... with 3 more variables: countries &lt;chr&gt;, languages &lt;chr&gt;, type &lt;chr&gt;</code></pre>
<p>Each rune is just a number, and the job of utf-8 is to encode that number (i.e.¬†its bits) into a sequence of bytes. To do this utf-8 uses a variable number of bytes.</p>
<p>For each rune: - The number of leading 1 in the first byte indicate the number of bytes that the rune need - The following bytes all start with ‚Äú10‚Äù - All the bits that are not used by this system are used to store the binary representation of the rune.</p>
<p>It sounds like a lot of words, so the <code>utf8splain::runes</code> function is here to help you.</p>
