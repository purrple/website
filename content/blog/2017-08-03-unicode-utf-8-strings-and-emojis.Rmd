---
title: Unicode, utf-8, strings and emojis
author: Romain Fran√ßois
date: '2017-08-03'
slug: unicode-utf-8-strings-and-emojis
categories: []
tags:
  - unicode
  - utf8
  - strings
  - emojis
  - utf8splain
  - uni
  - package
  - R
banner: "img/banners/utf8splain.png"
---

```{r echo=FALSE, message=FALSE, warning=FALSE}
library(tidyverse)
```


I've been somewhat obsessing about emojis lately, it all started when I wanted to 
check which emojis were used [on twitter](http://romain.rbind.io/blog/2017/07/11/emojis-at-user2017/) 
during useR this year. 

`r htmltools::HTML("{{< tweet 883199852347367424 >}}")`

But this post is not really about emojis, because my [emojitsu](https://github.com/ThinkRstat/emojitsu)
package is not ready yet, but here's a preview anyway. 

`r htmltools::HTML("{{< tweet 892375718247706626 >}}")`

So I'll blog specifically about emojis later, but this has led me to digress down
the üêá hole, because emojis are made of unicode runes typically encoded into utf-8 strings. Most of the 
concepts in that last sentence were quite mysterious to me not so long ago, and I believe we should
collectively know more about unicode and utf-8. I learned some of the basics from 
the [Strings, bytes, runes and characters in Go](https://blog.golang.org/strings) post in the go 
blog, and [The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)](https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/). 

Typically when I want to understand something, I make an R üì¶, I guess I really want 
to understand this, as I am making not 1, not 2 but 3 üì¶üì¶üì¶ (if I count `emojitsu`). 

 - üì¶ `uni` : contains a tibble of unicode runes
 - üì¶ `utf8splain` : to get to the 0Ô∏è‚É£ and 1Ô∏è‚É£ of utf-8 string encoding
 - üì¶ `emojitsu` : grammar of emoji, or at least programmatic manipulation of them. 
 
The üåç has changed now, and strings can no longer be considered as mere sequences of single 
characters (bytes). The `uni::code` tibble contains the `r nrow(uni::code)` unicode runes 
(aka code points). btw, the generation of the `uni::code` tibble contains some interesting 
tidyverse üèã, perhaps I'll ‚úçÔ∏è another post about that, but let's not digress more yet. 

```{r}
uni::code
```

So as of now, unicode has `r nrow(uni::code)` runes, that's way more
than the 256 that can fit into a single byte (8 bits), however we still want to be able to 
process text from back in the days when strings were in fact arrays of single bytes. 

Unicode is just a giant map of characters, that covers all languages, emojis and other things I don't know 
about, currently ranging between `r uni::code$rune[1]` and `r tail(uni::code$rune, 1)`. 

```{r}
uni::code %>% 
  slice( c(1, n()) )
```

Each rune is just a number, and the job of utf-8 is to encode that number (i.e. its bits) into 
a sequence of bytes. To do this utf-8 uses a variable number of bytes. 

For each rune: 
 - The number of leading 1 in the first byte indicate the number of bytes that the rune need
 - The following bytes all start with "10"
 - All the bits that are not used by this system are used to store the binary representation
  of the rune. 
  
It sounds like a lot of words, so the `utf8splain::runes` function is here to help you. 

```{r}
library(utf8splain)
runes( "hello üåç" )

```

... and if you use a [crayon üñç](https://github.com/r-lib/crayon) compatible console, like
a recent enough (maybe a daily build) of rstudio, you even get colour: 

<img src="/img/utf8splain/runes-crayon.png" width="100%" />

The first 6 characters are just ascii "h", "e", "l", "l", "o" and " ". They only need 7 bits, so 
they can be utf-8 encoded using just one byte. 

The 7th rune üåç is the rune "U+1F30D", i.e. binary encoded as: 

```{r}
world_decimal <- strtoi( "0x1F30D", base = 16)
world_decimal

world_binary    <- paste( substr(as.character( rev(intToBits(world_decimal)) ), 2, 2 ), collapse = "" )
world_binary

world_binary_signif <- sub( "^0+", "", world_binary )
world_binary_signif

nchar(world_binary_signif)
```

It needs `r nchar(world_binary_signif)` bits, in terms of utf-8 it means it needs 4 bytes (in red). These 4 bytes contain the utf-8 machinery (the light gray bits) and the actual binary bits for the rune (in black). To go full ‚≠ïÔ∏è the `runes` function extract the description of the runes using the 
`uni::code` üñº.  

Next time we'll see that some emojis actually use several runes, but until then I need to finish the 
`emojitsu` üì¶. 

